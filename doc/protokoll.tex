\documentclass[a4paper]{article}
\usepackage[utf8x]{inputenc}
\usepackage[german,ngerman]{babel}
\usepackage[a4paper,hmargin=2cm,vmargin=3cm]{geometry}
\usepackage[hyperindex=true]{hyperref}
\usepackage{tabularx}
\usepackage{graphics}

\setlength{\headheight}{27pt} % header with two lines
\setlength{\parindent}{0pt}
\setlength{\parskip}{4pt}

\title{Bachelor-Arbeit: Protokoll Spezifikation}
\author{Christoph Peltz}

\begin{document}
\maketitle
\tableofcontents
	\begin{tabularx}{\linewidth}{|l|l|l|l|X|}
		\hline
		\textbf{Version} & \textbf{Datum} & \textbf{Autor} 	& \textbf{Status} & \textbf{Kommentar} \\
		\hline
		\hline
		1 				 & 25.02.1009 	  & Christoph Peltz & 				  & Erste Version \\
		\hline
	\end{tabularx}

\pagebreak
	\section{Aktuelle Lage und Ziele}

	\subsection{Aktuelle Lage}

	Momentan besteht das Protokoll der Motorplatine aus einer Konkatenation von String-literalen, die eine bestimmt Form haben müssen.
	Wie z.B. "d,n,n,100,100" lässt das Fahrzeug ohne PID korrektur fahren, die beiden Räder werden mit der Geschwindigkeit 100
	betrieben und es werden keine Trigger verwendet. Diese Form des Protokolls ist für Menschen zwar gut lesbar und auch das Eintippen
	eines Befehles dieser Form ist sehr simpel, dies ist allerdings nicht der Fall für einen Computer, insbesondere die hier
	verwendeten Praktikumsplatinen können nicht besonders effizient mit Zeichenketten umgehen. Außerdem verbrauchen diese unnötigen
	Speicherplatz und auch dieser ist auf diesen eingebetten Systemen auch eine knappe Ressource mit der sehr sorgfältig umgegangen
	werden sollte. Zusätzlich wird durch die Länge eines Befehls die Geschwindigkeit mit der dieser Befehl zum einen über den Bus
	gesendet werden kann, als auch die Geschwindigkeit mit der er verarbeitet werden kann begrenzt. Denn die Befehle haben durch
	die Verwendung von Zeichenketten und die begrenzte Benutzung von den möglichen Werten eine längere Verarbeitungsdauer.

	\subsection{Ziele}

	Ein Teilziel der Bachelor-Arbeit ist das Protokoll Rechner-freundlich umzuschreiben. Das bedeutet zum einen, dass der Ansatz der
	Zeichenkettenrepräsentation der Befehle verworfen wird und stattdessen ein Byte-orientiertes Protokoll benutzt wird das eine
	wesentlich höhere Informationsdichte besitzt.


	\section{Protokoll}

	\subsection{Aufbau}

	Wie bereits eingangs erwähnt ist das Protokoll Byte-orientiert, das bedeutet also dass die Informationen der Befehle keine
	lesbare Repräsentation mehr sind. Von besonderer Wichtigkeit ist das erste Byte eines Befehls. Es definiert die Art des
	auszuführenden Befehls, sowie etwaige Optionen, die das Verhalten des Befehles verändern. Dazu ist das erste Byte logisch
	in zwei Teile unterteilt. Die ersten vier Bit (lies lower order bits) spezifizieren einen von 16 möglichen Befehlen
	(inklusive des Reservierten Befehls 0x00, dass für zukünftige Erweiterungen vorgesehen ist), die oberen vier Bit können
	Optionen für den ausgewählten Befehl sein. Alle nun darauf folgenden Bytes sind Parameter (mit der einen Ausnahme des
	0x0-Befehls, auch als Extended Instruction bezeichnet), deren Anzahl sich durch die Kombination von Befehl-Typ und
	Befehl-Optionen ergibt.
	Es gibt keine spezifischen Start und/oder Stop Muster, das Protokoll verlässt sich auf die ordentliche Übertragung
	der Daten und auf die korrekte Dateninhalte. Es können nur invalide Befehlsbytes erkannt und abgefangen werden, dies wird
	allerdings in der Implementation zugunste der einfacheren Behandlung nur bei invaliden Befehls-Typen getan. Invalide
	Optionen werden ignoriert.
	Eine weitere Eigenschaft des Protokolls ist, dass ein bestimmter Befehl immer gleich viele Bytes benötigt und die Anzahl
	der Bytes nicht von den Parametern abhängt (wie es im alten Protokoll der Fall war).
	\begin{figure}[!ht]
		\centering
		\scalebox{0.3}{
			\fbox{
				\includegraphics{Aufbau.png}
			}
		}
		\caption{Schematischer Aufbau eines Befehls und zweier Beispiele (mittleres ist ein Reset, unteres ein Fahrbefehl ohne
		Trigger mit den Geschwindigkeiten -128 und 10}
	\end{figure}

	\subsection{Extended Instruction - 0x00}

	Dieser Befehl ist für zukünftige Befehlserweiterungen zum Protokoll gedacht, falls mehr als 15 verschiedene Befehle
	benötigt werden. Wird dieser Befehl angetroffen, so werden nachfolgende Bytes als zusätzliche Befehlsbytes gewertet
	und besonders behandelt.
	In der aktuellen Implementierung wird nur das Befehlsbyte eingelesen, danach gilt der Befehl als beendet. Bei der
	Ausführung des Befehls wird nichts getan, nur der Befehlsstatus auf DONE gesetzt.

	\subsection{Control - 0x01}

	Dieser Befehls ist eher eine Befehlsgattung, der sehr unterschiedliche Optionen zu Verfügung stellt. So wird der
	Befehl benutzt um das Board und die Software zu reseten, die Ausführung des Aktuellen Befehls zu stoppen, den
	nächsten Befehl in der Warteschlange zu bearbeiten, einen Fahrstopp mit aktivem Bremsen auszuführen oder einfach die
	Warteschlange zu leeren. 
	Control-Befehle können nicht in die Warteschlange eingereiht werden und es kann nur eine gleichzeitig verarbeitet werden.
	Sie umgehen die Warteschlange und werden sogar während noch laufenden Befehlen ausgeführt. Sie erhalten den frühst
	möglichen Zeitslot zur Ausführung.

	\subsection{Register - 0x02}

	Durch diesen Befehl kann der Benutzer bestimmte virtuelle Register des Boards abfragen. Diese stellen dann Informationen
	wie z.B. die aktuelle Geschwindigkeit oder den aktuellen Befehl zu Verfügung.

	\subsection{Drive - 0x03}

	Mithilfe des Drive-Befehls werden allgemeine Fahrbefehle angenommen. Zu den Optionen zählen die Benutzung von Triggern
	auf Rad-Ebene, wie z.B. Kein Trigger, Positions-Trigger und Zeit-Trigger.

	\subsection{SetPID - 0x04}

	Durch diesen Befehl ist es möglich die Parameter für eine PID-Verbesserte-Fahrt selber zu setzen und somit für sich
	anzupassen.

	\subsection{PID-Drive - 0x05}

	Dieser Befehl schaltet eine PID-Verbeserte Fahrt ein, dadurch kann man zwar nur Geradeaus fahren, dies tut man dann aber
	sehr präzise.

	\subsection{0x06 - 0x0f}

	Diese Befehlscodes sind bisher nicht vergeben.


	\section{Befehlsreferenz}

	\subsection{0x00}

	Bisher werden Befehle mit diesem Code ignoriert.

	\subsection{0x01}

	\begin{tabularx}{\linewidth}{|l|l|X|}
		\hline
		\textbf{Option} & \textbf{Bitmaske} & \textbf{Beschreibung} \\
		\hline
		\hline
		Reset 			& 0x10 				& Resetet die Hardware \\
		\hline
		Stop Queue		& 0x20				& Der Aktuelle Befehl wird verworfen. Queue wird angehalten, aber nicht verworfen. \\
		\hline
		Continue Queue	& 0x30				& Der nächste Befehl in der Queue wird ausgeführt. \\
		\hline
		Clear Queue		& 0x40				& Die Warteschlange wird gelöscht. Aktueller Befehl wird aber weiter ausgeführt. \\
		\hline
		Stop Drive		& 0x50				& Befehl wird angehalten, Fahrzeug geht zum aktiven Bremsen über. \\
		\hline
	\end{tabularx}

	Um auf das richtige Befehlsbyte zu kommen muss die Option mit dem Befehl verundet werden. Als Beispiel dient hier das Löschen
	der Queue: 0x40 \& 0x01 = 0x41. Dies gilt für alle Befehle hier.
	Der Control-Befehl hat keine Parameter und ist damit konstant 1 Byte lang. Außerdem umgehet dieser Befehl die Warteschlange,
	wird also sofort ausgeführt, auch während noch ein anderer Befehl bearbeitet wird.

	\subsection{0x02}

	\begin{tabularx}{\linewidth}{|l|l|X|}
		\hline
		\textbf{Bitmaske} & \textbf{Beschreibung} & \textbf{Antwortlänge} \\
		\hline
		\hline
		0x10 				& Geschwindigkeit des linken Rades & 1 \\
		\hline
		0x20				& Geschwindigkeit des rechten Rades & 1 \\
		\hline
		0x30				& Anzahl der Befehl in der Queue & 1 \\
		\hline
		0x40				& Aktueller Befehl & 2 - 33 \\
		\hline
	\end{tabularx}
	
	Der Register-Befehl ist immer nur ein Byte lang, in den oberen 4 bit wird spezifiziert welche Informationen man haben möchte.
	Welche zur Verfügung stehen und welche Bitmaske man dafür verwenden muss, wird aus der obigen Tabelle entnommen. Es kann immer
	nur ein Register per Befehl abgefragt werden. Die Antwort auf solch eine Anfrage hat eine variable Länge, die ebenfalls aus
	der Tabelle entnommen werden kann (sie ist in Byte angegeben).
	Bei der Antwort mit dem Aktuellen Befehl ist das erste Byte die Längenangabe für den folgenden Befehl, darauf folgen die
	rohen Befehlsdaten (ohne Status). Das Byte der Längenangabe wird dabei NICHT mitgezähl (enthält also einen wert zwischen 1 und
	32).

	\subsection{0x03}

	Beim Drive Befehl sind die vier Optionsbits in zweimal zwei Bit unterteilt, die jeweils für ein Rad den Trigger angeben.

	\begin{tabularx}{\linewidth}{|l|l|l|X|}
		\hline
		\textbf{Option} & \textbf{Bitmaske linkes Rad} & \textbf{Bitmaske rechtes Rad} & \textbf{Beschreibung} \\
		\hline
		\hline
		Kein Trigger	& 0x00						   & 0x00						   & Endlosfahrt \\
		\hline
		Zeit Trigger	& 0x40						   & 0x10						   & zeitlich Begrenzte Fahrt\\
		\hline
		Positions Trigger & 0x80					   & 0x20						   & Fährt eine bestimmte Strecke \\
		\hline
	\end{tabularx}
	
	Hier müssen für beide Räder eine Options ausgewählt werden und zusammen auf den Befehl geundet werden. Beispiel linkes
	Rad benutzt einen Zeit Trigger, das rechte einen Positionstrigger: 0x40 \& 0x20 \& 0x03 = 0x63.
	Der Befehl erwartet mindestens zwei Parameter, die jeweils ein Byte lang sind und die Geschwindigkeit vom linken und
	vom rechten Rad angeben.

	\begin{tabularx}{\linewidth}{|l|l|l|X|}
		\hline
		\textbf{Byte Anzahl} & \textbf{Option} & \textbf{Wertebereich} & \textbf{Beschreibung} \\
		\hline
		\hline
		1					 & - & -128 bis 127 & Geschwindigkeit des linken Rades \\
		\hline
		1					 & - & -128 bis 127 & Geschwindigkeit des rechten Rades\\
		\hline
		2					 & Zeit Trigger & 0 bis 65535 &  Anzahl der ms die das linke Rad fährt\\
		\hline
		2					 & Positions Trigger & 0 bis 65535 &  Anzahl der Ticks die das linke Rad fährt\\
		\hline
		2					 & Zeit Trigger & 0 bis 65535 &  Anzahl der ms die das rechte Rad fährt\\
		\hline
		2					 & Positions Trigger & 0 bis 65535 &  Anzahl der Ticks die das rechte Rad fährt\\
		\hline
	\end{tabularx}
	
	Die Parameter werden in der Reihenfolge erwartet die hier angegeben wurde wobei die Zeit und Positionsparameter nur
	angegeben werden müssen wenn für des entsprechende Rad dies auch in den Optionen aktiviert wurde.
	Die Minimale Länge beläuft sich damit auf 3 Byte (1 Byte Kommando + 2 Byte für die Geschwindigkeiten) und die
	Maximale auf 7 Byte (1 Byte Kommando + 2 Byte Geschwindigkeit + 2*2 Byte für Trigger-Werte pro Rad).

	\subsection{0x04}

	Noch nicht implementiert oder definiert.

	\subsection{0x05}

	\begin{tabularx}{\linewidth}{|l|l|l|X|}
		\hline
		\textbf{Option} & \textbf{Bitmaske} & \textbf{Beschreibung} \\
		\hline
		\hline
		Kein Trigger	& 0x00						   & Endlosfahrt \\
		\hline
		Zeit Trigger	& 0x10						   & zeitlich Begrenzte Fahrt\\
		\hline
		Positions Trigger & 0x20						   & Fährt eine bestimmte Strecke \\
		\hline
	\end{tabularx}
	
	\begin{tabularx}{\linewidth}{|l|l|l|X|}
		\hline
		\textbf{Byte Anzahl} & \textbf{Option} & \textbf{Wertebereich} & \textbf{Beschreibung} \\
		\hline
		\hline
		1					 & - & -128 bis 127 & Geschwindigkeit der Räder \\
		\hline
		2					 & Zeit Trigger & 0 bis 65535 &  Anzahl der ms die das Gerät fährt\\
		\hline
		2					 & Positions Trigger & 0 bis 65535 &  Anzahl der Ticks die das Gerät fährt\\
		\hline
	\end{tabularx}

	Die selben Bedingungen und Angaben wie beim 0x03-Code gelten auch hier. Die Minimale Länge beträgt hier
	allerdings nur 2 Byte (1 Byte Kommando + 1 Byte Geschwindigkeit) und die Maximale Länge 4 Byte (1 Byte
	Kommando + 1 Byte Geschwindigkeit + 2 Byte Trigger).
	

\end{document}
