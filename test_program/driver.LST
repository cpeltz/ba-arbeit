C51 COMPILER V8.09   DRIVER                                                                07/07/2009 11:16:20 PAGE 1   


C51 COMPILER V8.09, COMPILATION OF MODULE DRIVER
OBJECT MODULE PLACED IN driver.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE driver.c DEBUG OBJECTEXTEND

line level    source

   1          #include <string.h>
   2          #include <stdlib.h>
   3          #include <stdio.h>
   4          
   5          #include "driver.h"
   6          #include "i2c_master.h"
   7          #include "helper.h"
   8          #include "timing.h"
   9          #include "lcd.h"
  10          #include "config.h"
  11          
  12          /** Kommando-Buffer */
  13          byte xdata driver_buffer[DRIVER_BUFFER_SIZE];
  14          
  15          int driver_pos_overflows = 0;
  16          int driver_last_pos = 0;
  17          
  18          void add_drive_param(char * str, int value) {
  19   1              strcat(str, ",");
  20   1              int2str(str + strlen(str), value);
  21   1      }
  22          
  23          static DriverStatus driver_statusStrct;
  24          
  25          void driver_drive(signed char speedLeft, signed char speedRight, driver_trigger trigger,
  26                          int triggerValLeft, int triggerValRight) {
  27   1              // Setze die Adresse und den Fahrmodus
  28   1              strcpy(driver_buffer, "  D");
  29   1              driver_buffer[0] = DRIVER_ADDRESS;
  30   1              driver_buffer[1] = 0xf3;
  31   1      
  32   1              switch (trigger) {
  33   2                      case TRIGGER_NONE:
  34   2                              strcat(driver_buffer, "NN");
  35   2                              break;
  36   2                      case TRIGGER_TIME:
  37   2                              // Sanity-check
  38   2                              if ((triggerValLeft  > 255) || (triggerValLeft  < 1) ||
  39   2                                  (triggerValRight > 255) || (triggerValRight < 1))
  40   2                                      return;
  41   2      
  42   2                              strcat(driver_buffer, "TT");
  43   2                              break;
  44   2                      case TRIGGER_POSITION:
  45   2                              strcat(driver_buffer, "PP");
  46   2                              break;
  47   2              }
  48   1      
  49   1              // Fuege die Parameter zur Zeichenkette hinzu
  50   1              add_drive_param(driver_buffer, speedLeft);
  51   1              add_drive_param(driver_buffer, speedRight);
  52   1              add_drive_param(driver_buffer, triggerValLeft);
  53   1              add_drive_param(driver_buffer, triggerValRight);        
  54   1      
  55   1      //      lcd_print_string(driver_buffer + 2);
C51 COMPILER V8.09   DRIVER                                                                07/07/2009 11:16:20 PAGE 2   

  56   1      //      wait_ms(5000);
  57   1              // Befehlskette an den i²c-Bus senden
  58   1              i2c_send(driver_buffer, strlen(driver_buffer) + 1);
  59   1      
  60   1              driver_buffer[0] = DRIVER_ADDRESS;
  61   1              driver_buffer[1] = 'J';
  62   1              i2c_send(driver_buffer, 2);
  63   1      }
  64          
  65          void driver_driveStraight(int speed, driver_trigger trigger, int triggerVal) {
  66   1              driver_drive(speed, speed, trigger, triggerVal, triggerVal);
  67   1      }
  68          
  69          void driver_rotate(signed char speed, int degree) {
  70   1              char dir = 0;
  71   1              char speedRight = speed;
  72   1              int degreeRight;
  73   1      
  74   1              if (degree < 0) {
  75   2                      dir = 1;
  76   2                      degree = -degree;
  77   2                      speedRight = -speed;
  78   2              } else {
  79   2                      speed = -speed;
  80   2              }
  81   1      
  82   1              degree = ((degree * 20) + degree * 2) / 10;
  83   1      
  84   1              if (dir == 0) {
  85   2                      degreeRight = degree;
  86   2                      degree = -degree;
  87   2              } else
  88   1                      degreeRight = -degree;
  89   1      
  90   1              driver_drive(speed, speedRight, TRIGGER_POSITION, degree, degreeRight);
  91   1      }
  92          
  93          void driver_stop() {
  94   1              // Fahrzeug anhalten und Befehlskette loeschen
  95   1              driver_buffer[0] = DRIVER_ADDRESS;      
  96   1              driver_buffer[1] = ' ';
  97   1              i2c_send(driver_buffer, 2);
  98   1      }
  99          
 100          void driver_pause() {
 101   1              driver_buffer[0] = DRIVER_ADDRESS;      
 102   1              driver_buffer[1] = 'p';
 103   1              i2c_send(driver_buffer, 2);
 104   1      }
 105          
 106          void driver_unpause() {
 107   1              driver_buffer[0] = DRIVER_ADDRESS;      
 108   1              driver_buffer[1] = 'P';
 109   1              i2c_send(driver_buffer, 2);
 110   1      }
 111          
 112          void driver_moveForward() {
 113   1              driver_buffer[0] = DRIVER_ADDRESS;
 114   1              driver_buffer[1] = 'w';
 115   1              i2c_send(driver_buffer, 2);
 116   1      }
 117          
C51 COMPILER V8.09   DRIVER                                                                07/07/2009 11:16:20 PAGE 3   

 118          void driver_moveBackward() {
 119   1              driver_buffer[0] = DRIVER_ADDRESS;
 120   1              driver_buffer[1] = 's';
 121   1              i2c_send(driver_buffer, 2);
 122   1      }
 123          
 124          void driver_rotateLeft() {
 125   1              driver_buffer[0] = DRIVER_ADDRESS;
 126   1              driver_buffer[1] = 'a';
 127   1              i2c_send(driver_buffer, 2);
 128   1      }
 129          
 130          void driver_rotateRight() {
 131   1              driver_buffer[0] = DRIVER_ADDRESS;
 132   1              driver_buffer[1] = 'd';
 133   1              i2c_send(driver_buffer, 2);
 134   1      }
 135          
 136          DriverStatus *driver_status() {
 137   1              byte numRead;
 138   1      
 139   1              driver_buffer[0] = DRIVER_ADDRESS;
 140   1              driver_buffer[1] = 0xf0;
 141   1      
 142   1              /*// Position des linken Rades
 143   1              driver_buffer[2] = 1;
 144   1              i2c_send(driver_buffer, 3);
 145   1              driver_buffer[3] = DRIVER_ADDRESS;
 146   1              driver_buffer[4] = 0xff;
 147   1              numRead = i2c_receive(driver_buffer + 3, 2);
 148   1              driver_statusStrct.posLeft = driver_buffer[4] << 8;
 149   1      
 150   1              driver_buffer[2] = 2;
 151   1              i2c_send(driver_buffer, 3);
 152   1              driver_buffer[3] = DRIVER_ADDRESS;
 153   1              driver_buffer[4] = 0xff;
 154   1              numRead = i2c_receive(driver_buffer + 3, 2);
 155   1              driver_statusStrct.posLeft += driver_buffer[4];
 156   1      
 157   1              // Position des rechten Rades
 158   1              driver_buffer[2] = 3;
 159   1              i2c_send(driver_buffer, 3);
 160   1              driver_buffer[3] = DRIVER_ADDRESS;
 161   1              driver_buffer[4] = 0xff;
 162   1              numRead = i2c_receive(driver_buffer + 3, 2);
 163   1              driver_statusStrct.posRight = driver_buffer[4] << 8;
 164   1      
 165   1              driver_buffer[2] = 4;
 166   1              i2c_send(driver_buffer, 3);
 167   1              driver_buffer[3] = DRIVER_ADDRESS;
 168   1              driver_buffer[4] = 0xff;
 169   1              numRead = i2c_receive(driver_buffer + 3, 2);
 170   1              driver_statusStrct.posRight += driver_buffer[4];*/
 171   1      
 172   1              // Geschwindigkeit des linken Rades
 173   1              driver_buffer[2] = 5;
 174   1              i2c_send(driver_buffer, 3);
 175   1              driver_buffer[3] = DRIVER_ADDRESS;
 176   1              driver_buffer[4] = 0xff;
 177   1              numRead = i2c_receive(driver_buffer + 3, 2);
 178   1              driver_statusStrct.speedLeft = driver_buffer[4];
 179   1      
C51 COMPILER V8.09   DRIVER                                                                07/07/2009 11:16:20 PAGE 4   

 180   1              // Geschwindigkeit des rechten Rades
 181   1              driver_buffer[2] = 6;
 182   1              i2c_send(driver_buffer, 3);
 183   1              driver_buffer[3] = DRIVER_ADDRESS;
 184   1              driver_buffer[4] = 0xff;
 185   1              numRead = i2c_receive(driver_buffer + 3, 2);
 186   1              driver_statusStrct.speedRight = driver_buffer[4];
 187   1      
 188   1              // Anzahl der Eintraege in der Queue
 189   1              driver_buffer[2] = 10;
 190   1              i2c_send(driver_buffer, 3);
 191   1              driver_buffer[3] = DRIVER_ADDRESS;
 192   1              driver_buffer[4] = 0xff;
 193   1              numRead = i2c_receive(driver_buffer + 3, 2);
 194   1              driver_statusStrct.mode = driver_buffer[4];
 195   1      
 196   1              // Tachowert links
 197   1              driver_buffer[2] = 12;
 198   1              i2c_send(driver_buffer, 3);
 199   1              driver_buffer[3] = DRIVER_ADDRESS;
 200   1              driver_buffer[4] = 0xff;
 201   1              numRead = i2c_receive(driver_buffer + 3, 2);
 202   1              driver_statusStrct.tachoLeft = driver_buffer[4] << 8;
 203   1      
 204   1              driver_buffer[2] = 13;
 205   1              i2c_send(driver_buffer, 3);
 206   1              driver_buffer[3] = DRIVER_ADDRESS;
 207   1              driver_buffer[4] = 0xff;
 208   1              numRead = i2c_receive(driver_buffer + 3, 2);
 209   1              driver_statusStrct.tachoLeft += driver_buffer[4];
 210   1      
 211   1              // Tachowert rechts
 212   1              driver_buffer[2] = 14;
 213   1              i2c_send(driver_buffer, 3);
 214   1              driver_buffer[3] = DRIVER_ADDRESS;
 215   1              driver_buffer[4] = 0xff;
 216   1              numRead = i2c_receive(driver_buffer + 3, 2);
 217   1              driver_statusStrct.tachoRight = driver_buffer[4] << 8;
 218   1      
 219   1              driver_buffer[2] = 15;
 220   1              i2c_send(driver_buffer, 3);
 221   1              driver_buffer[3] = DRIVER_ADDRESS;
 222   1              driver_buffer[4] = 0xff;
 223   1              numRead = i2c_receive(driver_buffer + 3, 2);
 224   1              driver_statusStrct.tachoRight += driver_buffer[4];
 225   1      
 226   1              return &driver_statusStrct;
 227   1      }
 228          
 229          int driver_get_pos() {
 230   1              driver_save_pos();
 231   1              return driver_pos_overflows * DRIVER_CM_PER_OVERFLOW + driver_pos_to_cm(driver_last_pos);
 232   1      }
 233          
 234          void driver_save_pos() {
 235   1              DriverStatus *ds = driver_status();
 236   1              int pos = ds->tachoLeft / 2 + ds->tachoRight / 2;
 237   1              if((driver_last_pos < 0 && driver_last_pos < (-32768 + DRIVER_OVERFLOW_DELTA) && pos > (0 - DRIVER_OVERFL
             -OW_DELTA))
 238   1                              || (driver_last_pos > 0 && driver_last_pos > (32767 - DRIVER_OVERFLOW_DELTA) && pos < DRIVER_OVERFLOW_D
             -ELTA)) { // tick counter of motor has had overflow
 239   2                      driver_pos_overflows++;
C51 COMPILER V8.09   DRIVER                                                                07/07/2009 11:16:20 PAGE 5   

 240   2              }
 241   1              driver_last_pos = pos;
 242   1      }
 243          
 244          void driver_reset_pos() {
 245   1              driver_buffer[0] = DRIVER_ADDRESS;
 246   1              driver_buffer[1] = 116; // Send 't' to motor, resets tacho
 247   1              i2c_send(driver_buffer, 2);
 248   1      
 249   1              driver_pos_overflows = 0;
 250   1              driver_last_pos = 0;
 251   1      }
 252          
 253          int driver_pos_to_cm(int pos) {
 254   1              return (pos / DRIVER_TICKS_PER_CM);
 255   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1161    ----
   CONSTANT SIZE    =     15    ----
   XDATA SIZE       =     40    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     11      20
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
