C51 COMPILER V8.09   I2C_MASTER                                                            07/23/2009 15:03:50 PAGE 1   


C51 COMPILER V8.09, COMPILATION OF MODULE I2C_MASTER
OBJECT MODULE PLACED IN i2c_master.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE i2c_master.c LARGE BROWSE INTVECTOR(0X2000) DEFINE(MONITOR51) DEBUG OBJECTE
                    -XTEND

line level    source

   1          
   2          /*******************************************************
   3           **  Mikroprozessorlabor                              **
   4           **                                                   **
   5           **  Institut für Betriebssysteme und Rechnerverbund  **
   6           **  Technische Universität Braunschweig              **
   7           *******************************************************/
   8          
   9          // File :  i2c_master.c 
  10          // Modul:  i2c (Master-Modus)
  11          // Vers.:  1.01
  12          // Autor:  Rilk, Markus 
  13          // Letzte Änderung: 2002.09.30.
  14          //*****************************
  15          
  16          
  17          
  18          // ----- Includes -----
  19          //=====  
  20          
  21          
  22          //================
  23          
  24          #include <REG552.H>               // special function register declarations
  25          #include "i2c_master.h"
  26          #include "config.h"
  27          
  28          // ----- Deklarationen, die nur innerhalb dieser Datei gebraucht werden -----
  29          // ==========================================================================
  30          
  31          void checkStatus(byte i2cStatus);
  32          
  33          
  34          // ----- Funktionsdefinitionen -----
  35          // =================================
  36          
  37          
  38          // --- Globale Variablen ---
  39          
  40          byte xdata *i2cBuf;              // Zeiger auf Sende- bzw. Empfangspuffer
  41          byte xdata i2cBufSize;   // Größe des aktuellen Puffers
  42          byte xdata i2cBufIndex;  // Aktuelle Position im Puffer
  43          byte xdata i2cAttempts;  // Anzahl der Verbindungsversuche
  44          byte xdata i2cStartByte; // Slave-Adresse + Lesen oder Schreiben
  45          bit i2cBusy;                     // Busy-Flag
  46          
  47          
  48          
  49          // Interrupthandler für I2C-Bus Schnittstelle (S1-Interrupt)
  50          void i2c_interrupt() interrupt 5 {      
  51   1              byte xdata i2cStatus = S1STA;   // Kopiert Status in temporäre Variable
  52   1              checkStatus(i2cStatus);
  53   1      }
  54          
C51 COMPILER V8.09   I2C_MASTER                                                            07/23/2009 15:03:50 PAGE 2   

  55          
  56          // Prüfe den Status
  57          void checkStatus(byte i2cStatus) {
  58   1              switch(i2cStatus) 
  59   1              {
  60   2              case 0x08:
  61   2                      // State: 0x08 - START Zustand wurde gesendet
  62   2                      // Mode: Master-Transeiver
  63   2                      // Action: SLR+RW werden gesendet, ACK Bit empfangen
  64   2              case 0x10:
  65   2                      // State: 0x10 - START wurde wiederholt gesendet
  66   2                      // Mode: Master-Transeiver
  67   2                      // Action: SLR+RW werden gesendet, ACK Bit empfangen
  68   2                      S1DAT = i2cStartByte;                           
  69   2                      S1CON = 0xC5;           
  70   2                      break;
  71   2                              
  72   2              case 0x18:
  73   2                      // State: 0x18 - SLR+W wurde gesendet, ACK Bit empfangen
  74   2                      // Mode: Master-Transmitter
  75   2                      // Action: Datenbyte senden oder Bus freigeben
  76   2              case 0x28:
  77   2                      // State: 0x28 - Datenbyte wurde gesendet, ACK Bit empfangen
  78   2                      // Mode: Master-Transmitter
  79   2                      // Action: Datenbyte senden oder Bus freigeben
  80   2                      i2cBufIndex++;
  81   2                      if(i2cBufIndex == i2cBufSize)
  82   2                      {
  83   3                              // Es wurde der gesamte Puffer übertragen -> Ende
  84   3                              S1CON = 0xD5;
  85   3                              i2cBusy = 0;
  86   3                      }
  87   2                      else
  88   2                      {
  89   3                              // Übertrage die nächsten Daten
  90   3                              S1DAT = i2cBuf[i2cBufIndex];
  91   3                                                      S1CON = 0xC5;
  92   3                      }
  93   2                      break;
  94   2      
  95   2              case 0x48:
  96   2                      // State: 0x48 - SLA+R wurde gesendet, NOT ACK Bit empfangen
  97   2                      // Mode: Master-Receiver
  98   2                      // Action: Wiederholte Startbedingung oder Abbruch, falls zuviele Versuche
  99   2              case 0x20:
 100   2                      // State: 0x20 - SLA+W wurde gesendet, NOT ACK Bit empfangen
 101   2                      // Mode: Master-Transmitter
 102   2                      // Action: Wiederholte Startbedingung oder Abbruch, falls zuviele Versuche
 103   2                      if(i2cAttempts < I2C_MAX_ATTEMPTS)
 104   2                      {
 105   3                              S1CON = 0xE5; // Sende erneut Startbedingung
 106   3                              i2cAttempts++;
 107   3                      }
 108   2                      else
 109   2                      {
 110   3                              S1CON = 0xD5; // Sende Stopbedingung
 111   3                              i2cBusy = 0;
 112   3                      }
 113   2                      break;
 114   2      
 115   2              case 0x50:
 116   2                      // State 0x50: Datenbyte wurde empfangen, ACK Bit gesendet
C51 COMPILER V8.09   I2C_MASTER                                                            07/23/2009 15:03:50 PAGE 3   

 117   2                      // Mode: Master-Receiver
 118   2                      // Action: Bus freigeben oder Empfang weiterer Daten
 119   2                      i2cBuf[i2cBufIndex] = S1DAT;
 120   2              case 0x40:
 121   2                      // State 0x40: SLA+R gesendet, Ack Bit empfangen
 122   2                      // Mode: Master-Receiver
 123   2                      // Action: Empfange Daten, Ack Bit senden
 124   2                      i2cBufIndex++;
 125   2                      
 126   2                      if(i2cBufIndex == i2cBufSize - 1) 
 127   2                      {
 128   3                              S1CON = 0xC1;   // NOT ACK senden
 129   3                      } 
 130   2                      else 
 131   2                      {       
 132   3                              S1CON = 0xC5;   // ACK senden und nächstes Byte empfangen
 133   3                      }
 134   2                      break;
 135   2      
 136   2              case 0x58:
 137   2                      // State 0x58: Datenbyte wurde empfangen, NOT ACK Bit wurde gesendet
 138   2                      // Mode: Master-Receiver
 139   2                      // Action: Datenbyte lesen, Datentransfer stoppen, Bus freigeben 
 140   2                      i2cBuf[i2cBufIndex] = S1DAT;
 141   2                      i2cBufIndex++;
 142   2              default:
 143   2                      // Empfang abbrechen und Bus freigeben
 144   2                      S1CON = 0xD5;
 145   2                      i2cBusy = 0;
 146   2                      break;
 147   2              }
 148   1      }
 149          
 150          
 151          // Sende Daten zum Slave
 152          // <buffer>:    buffer[0] - Adresse des Empfängers      
 153          //                              buffer[n] (n != 0) - Daten, die gesendet werden sollen
 154          // <size>:              Größe von <buffer> 
 155          // <return>:    Anzahl der gesendeten Daten
 156          byte i2c_send(byte* buffer, byte size) 
 157          {
 158   1              i2cBuf = buffer;
 159   1              i2cBufSize = size;
 160   1              i2cAttempts = 0;
 161   1                      
 162   1              i2cStartByte = *i2cBuf << 1;    // LSB == 0 für Schreibvorgang
 163   1              
 164   1              i2cBusy = 1;
 165   1              STA = 1;        // Sende Startbit
 166   1              i2cBufIndex = 0;        
 167   1              
 168   1              while(i2cBusy == 1);    // Warten bis Sendeende oder Abbruch
 169   1              return i2cBufIndex;
 170   1      }
 171          
 172          
 173          // Empfange Daten vom Slave
 174          // <buffer>:    buffer[0] - Adresse des Empfängers      
 175          //                              buffer[n] (n != 0) - Speicher für die empfangenen Daten
 176          // <size>:              Größe von <buffer> 
 177          // <return>:    Anzahl der empfangenen Daten
 178          byte i2c_receive(byte *buffer, byte size) 
C51 COMPILER V8.09   I2C_MASTER                                                            07/23/2009 15:03:50 PAGE 4   

 179          {
 180   1              if(size < 2) return 0;
 181   1      
 182   1              i2cBuf = buffer;
 183   1              i2cBufSize = size;
 184   1              i2cAttempts = 0;
 185   1      
 186   1              i2cStartByte = (*i2cBuf << 1) | 0x01;   // LSB == 1 für Lesevorgang
 187   1              i2cBusy = 1;
 188   1              STA = 1;        // Sende Startbit
 189   1              i2cBufIndex = 0;        
 190   1              
 191   1              while(i2cBusy == 1);    // Warten bis Empfangsende oder Abbruch
 192   1              return i2cBufIndex;
 193   1      }
 194          
 195          
 196          // Initialisiere I2C-Interface
 197          void i2c_init() 
 198          {
 199   1              i2cBusy = 0;            // Busy Flag rücksetzen 
 200   1              S1CON = 0xC5;           // 100khz i2c 
 201   1              
 202   1              S1ADR = 0x01;           // Eigene Slave Adresse 
 203   1              
 204   1              SDA = 1;                        // Portpins setzen, um Port-Read zu ermöglichen 
 205   1              SCL = 1;
 206   1              
 207   1              ES1 = 1;
 208   1              ENS1 = 1;                       // I2C Interrupt freigeben 
 209   1              EA = 1;                         // Interrupte generell freigeben
 210   1      }
 211          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    376    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      6    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
