C51 COMPILER V8.09   PROTOCOL_HANDLER                                                      06/18/2009 11:03:20 PAGE 1   


C51 COMPILER V8.09, COMPILATION OF MODULE PROTOCOL_HANDLER
OBJECT MODULE PLACED IN protocol_handler.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE protocol_handler.c LARGE BROWSE INTVECTOR(0X2000) DEFINE(MONITOR51) DEBUG O
                    -BJECTEXTEND

line level    source

   1          #include <REG552.H>               // special function register declarations
   2          #include <stdlib.h>
   3          #include <stdio.h>
   4          #include <string.h>
   5          
   6          #include "protocol_handler.h"
   7          #include "driver.h"
   8          #include "lcd.h"
   9          #include "timing.h"
  10          #include "asm_helper.h"
  11          #include "servo.h"
  12          #include "sharp_sensor.h"
  13          
  14          byte sensor_last = 0;
  15          // command buffer
  16          byte xdata cmdSizeRec = 0;
  17          bit cmdReady = 0;
  18          unsigned int xdata cmdLen = 0;
  19          unsigned int xdata cmdBufferPos = 0;
  20          unsigned int xdata cmdSendBufferLen = 0;
  21          unsigned int xdata cmdSendBufferPos = 0;
  22          byte xdata cmdBuffer[PROTO_RECV_BUFFER_SIZE];
  23          byte xdata *cmdCond;
  24          byte xdata cmdSendBuffer[PROTO_SEND_BUFFER_SIZE];
  25          TimerStatus xdata condTimerStatus = TIMER_NOP;
  26          
  27          struct condVars {
  28                  byte op;
  29                  byte l, r;
  30                  int valueL, valueR;
  31          };
  32          
  33          struct condVars condStack[PROTO_MAX_RECURSION_DEPTH];
  34          signed char condStackPos = -1;
  35          
  36          void proto_fake() {
  37   1              cmdLen = 5;     
  38   1              cmdBuffer[0] = 2;
  39   1              cmdBuffer[1] = 40;
  40   1              cmdBuffer[2] = 2;
  41   1              cmdBuffer[3] = 50;
  42   1              cmdBuffer[4] = 1;
  43   1      } 
  44          
  45          void proto_init() {
  46   1              // Enable interrupt 4 (Serial Port)
  47   1      
  48   1              EA = 1;
  49   1      
  50   1              TI = 0;                         /* clear transmit interrupt */
  51   1              RI = 0;                         /* clear receiver interrupt */
  52   1      
  53   1              ES0 = 1;                        /* enable serial interrupts */
  54   1              PS0 = 0;                        /* set serial interrupts to low priority */
C51 COMPILER V8.09   PROTOCOL_HANDLER                                                      06/18/2009 11:03:20 PAGE 2   

  55   1      }
  56          
  57          void proto_interrupt() interrupt 4 {
  58   1              byte rec = 0;   // we use rec to assure that receiving and sending is done as quickly as possible
  59   1                                              // then we handle the received byte
  60   1              byte ch;
  61   1      
  62   1              if (RI != 0) { // did we receive anything?
  63   2                      RI = 0;
  64   2                      ch = S0BUF; // the received character
  65   2                      rec = 1;
  66   2              }
  67   1              
  68   1              if (TI != 0) { // can we transmit anything?
  69   2                      TI = 0;
  70   2      
  71   2                      if (cmdSendBufferPos < cmdSendBufferLen)
  72   2                              S0BUF = cmdSendBuffer[cmdSendBufferPos++];
  73   2              }
  74   1      
  75   1              if (!rec)
  76   1                      return; // nothing received => leave
  77   1      
  78   1              if (cmdSizeRec == 0) {
  79   2                      cmdLen = ch << 8;
  80   2                      cmdSizeRec = 1;
  81   2              } else if (cmdSizeRec == 1) {
  82   2                      cmdLen += ch;
  83   2                      cmdSizeRec = 2;
  84   2              } else {
  85   2                      cmdBuffer[cmdBufferPos] = ch;
  86   2                      cmdBufferPos++;
  87   2                      if(cmdBufferPos == cmdLen) { // command in buffer is complete
  88   3                              cmdSizeRec = 0;         
  89   3                              cmdReady = 1; // signal a ready command
  90   3                      }
  91   2              }
  92   1      }
  93          
  94          void proto_send(byte len) {
  95   1              EA = 0;
  96   1      
  97   1              cmdSendBufferPos = 0;
  98   1              cmdSendBufferLen = len;
  99   1      
 100   1              EA = 1;
 101   1      
 102   1              S0BUF = cmdSendBuffer[cmdSendBufferPos++];
 103   1      }
 104          
 105          bit proto_cmd_ready() {
 106   1              if (cmdReady) {
 107   2                      return 1;
 108   2              }
 109   1              else {
 110   2                      return 0;
 111   2              }
 112   1      }
 113          
 114          int proto_read_sensor(byte sensor) {
 115   1              unsigned int rs;
 116   1              byte i;
C51 COMPILER V8.09   PROTOCOL_HANDLER                                                      06/18/2009 11:03:20 PAGE 3   

 117   1      //      char xdata dbuf[20];
 118   1              if(sensor == 11) {
 119   2                      return driver_get_pos();
 120   2              }
 121   1              sensor %= 11;
 122   1              if(sensor <= 5) {
 123   2                      if((sensor_last % 3) != (sensor % 3)) {
 124   3                              servo_set_pos(30 + (sensor % 3) * 60);
 125   3                              wait_ms(1000);
 126   3                      }
 127   2                      sensor_last = sensor;
 128   2                      sensor = (sensor <= 2) ? 0 : 1;
 129   2              }
 130   1              else {
 131   2                      sensor_last = sensor;
 132   2                      sensor -= 4;
 133   2              }
 134   1              rs = sharpa_measure(sensor);
 135   1              for(i = 0; i < 4; i++) {
 136   2                      wait_ms(50);
 137   2                      rs = (rs + sharpa_measure(sensor)) / 2;
 138   2              }
 139   1      //      sprintf(dbuf, "%u: %u", (unsigned int) (sensor), (unsigned int) (samplea_to_cm(rs, (sensor <= 2 ? SENSO
             -R_LONG_DIST : SENSOR_SHORT_DIST))));
 140   1      //      lcd_print_string(dbuf);
 141   1              return ((int) (samplea_to_cm(rs, (sensor <= 2 ? SENSOR_LONG_DIST : SENSOR_SHORT_DIST))));
 142   1      }
 143          
 144          void proto_wait_condition() {
 145   1              byte xdata *cmdCondPointer = cmdCond;
 146   1              while(proto_evaluate_cond(&cmdCondPointer)) {
 147   2                      //wait_ms(50);
 148   2                      driver_save_pos(); // save driver postition for next evaluation
 149   2                      cmdCondPointer = cmdCond;
 150   2              }
 151   1      }
 152          
 153          /*void proto_dump_message(byte *buf, byte len) {
 154                  char xdata sbuf[40];
 155                  byte i;
 156                  lcd_clear();
 157                  strcpy(sbuf, "Message:            ");
 158                  lcd_write_text(sbuf);
 159                  for(i = 0; i < len; i++) {
 160                          sprintf(sbuf, "%u ", (unsigned int) *(buf + i));
 161                          lcd_write_text(sbuf);
 162                  }
 163          }*/
 164          
 165          void proto_send_done() {
 166   1              cmdSendBuffer[0] = DONE;
 167   1              proto_send(1);
 168   1      }
 169          
 170          byte proto_evaluate_cond(byte xdata **buf) {
 171   1              if(condStackPos == (PROTO_MAX_RECURSION_DEPTH - 1)) {
 172   2                      lcd_print_string("Recursion depth exceeded!");
 173   2                      while(1);               
 174   2              }
 175   1      
 176   1              condStackPos++;
 177   1      
C51 COMPILER V8.09   PROTOCOL_HANDLER                                                      06/18/2009 11:03:20 PAGE 4   

 178   1              condStack[condStackPos].op = 0;
 179   1              if(buf == 0 || *buf == 0) {
 180   2                      return 0;
 181   2              }
 182   1              condStack[condStackPos].op = **buf;
 183   1              (*buf)++;
 184   1              switch(condStack[condStackPos].op) {
 185   2                      case BFALSE:                    
 186   2                              condStackPos--;
 187   2                              return 0;
 188   2                      case BTRUE:                     
 189   2                              condStackPos--;
 190   2                              return 1;
 191   2                      case NOT:                       
 192   2                              condStackPos--;
 193   2                              return !proto_evaluate_cond(buf);
 194   2                      case AND:
 195   2                      case OR:                        
 196   2                              condStack[condStackPos].l = 0;
 197   2                              condStack[condStackPos].r = 0;
 198   2                              condStack[condStackPos].l = proto_evaluate_cond(buf);
 199   2                              condStack[condStackPos].r = proto_evaluate_cond(buf);
 200   2                              condStackPos--;
 201   2                              if(condStack[condStackPos + 1].op==AND) {
 202   3                                      return (condStack[condStackPos + 1].l && condStack[condStackPos + 1].r);
 203   3                              } else {
 204   3                                      return (condStack[condStackPos + 1].l || condStack[condStackPos + 1].r);
 205   3                              }                               
 206   2                              break;
 207   2                      case GT:
 208   2                      case EQ:                        
 209   2                              condStack[condStackPos].valueL = 0;
 210   2                              condStack[condStackPos].valueR = 0;
 211   2                              switch(**buf) {
 212   3                                      case CONST_INT:
 213   3                                              (*buf)++;
 214   3                                              condStack[condStackPos].valueL = (int) ((**buf)<<8);
 215   3                                              (*buf)++;
 216   3                                              condStack[condStackPos].valueL += (int) (**buf);
 217   3                                              (*buf)++;
 218   3                                              break;
 219   3                                      case SENSOR:
 220   3                                              (*buf)++;
 221   3                                              condStack[condStackPos].valueL = proto_read_sensor(**buf);
 222   3                                              (*buf)++;
 223   3                                              break;
 224   3                                      default:
 225   3                                              lcd_print_string("NUM ERROR_1!");
 226   3                                              break;
 227   3                              }
 228   2                              switch(**buf) {
 229   3                                      case CONST_INT:
 230   3                                              (*buf)++;
 231   3                                              condStack[condStackPos].valueR = (int) ((**buf)<<8);
 232   3                                              (*buf)++;
 233   3                                              condStack[condStackPos].valueR += (int) (**buf);
 234   3                                              (*buf)++;
 235   3                                              break;
 236   3                                      case SENSOR:
 237   3                                              (*buf)++;
 238   3                                              condStack[condStackPos].valueR = proto_read_sensor(**buf);
 239   3                                              (*buf)++;
C51 COMPILER V8.09   PROTOCOL_HANDLER                                                      06/18/2009 11:03:20 PAGE 5   

 240   3                                              break;
 241   3                                      default:
 242   3                                              lcd_print_string("NUM ERROR_2!");
 243   3                                              break;
 244   3                              }
 245   2                              switch(condStack[condStackPos].op) {
 246   3                                      case GT:
 247   3                                              condStackPos--;
 248   3                                              return (condStack[condStackPos+1].valueL > condStack[condStackPos+1].valueR);
 249   3                                              break;
 250   3                                      case EQ:                                        
 251   3                                              condStackPos--;
 252   3                                              return (condStack[condStackPos+1].valueL == condStack[condStackPos+1].valueR);
 253   3                                              break;
 254   3                              }                       
 255   2                              break;
 256   2                      case TIME_LIMIT:
 257   2                              {
 258   3                                      unsigned int timeLimit = 0;
 259   3                                      timeLimit = (**buf)<<8;
 260   3                                      (*buf)++;
 261   3                                      timeLimit += **buf;
 262   3                                      (*buf)++;
 263   3                                      switch(condTimerStatus) {
 264   4                                              case TIMER_NOP:                                         
 265   4                                                      wait_with_timer(timeLimit);
 266   4                                                      condStackPos--;
 267   4                                                      return 1;
 268   4                                                      break;
 269   4                                              case TIMER_STARTED:
 270   4                                                              condStackPos--;
 271   4                                                      return 1;
 272   4                                                      break;
 273   4                                              case TIMER_REACHED:
 274   4                                                      condStackPos--;
 275   4                                                      return 0;
 276   4                                                      break;
 277   4                                              default:
 278   4                                                      lcd_print_string("TIMER ERROR!");
 279   4                                                      break;
 280   4                                      }
 281   3                              }
 282   2                              break;
 283   2                      default:                        
 284   2                              lcd_print_string("OP ERROR!");
 285   2                              break;
 286   2              }
 287   1              condStackPos--;
 288   1              return 0;
 289   1      }
 290          
 291          void proto_execute() {
 292   1              byte pos = 0;
 293   1              char speed = 0;
 294   1              byte moveType = 0, dir = 0, func = 0;
 295   1              DriverStatus *drvStatus = 0;
 296   1              byte xdata *cmdCondPointer;
 297   1              if(cmdBuffer == 0) {
 298   2                      return;
 299   2              }
 300   1      
 301   1              condTimerStatus = TIMER_NOP;
C51 COMPILER V8.09   PROTOCOL_HANDLER                                                      06/18/2009 11:03:20 PAGE 6   

 302   1              cmdReady = 0; // the command isn't ready anymore...
 303   1              switch(cmdBuffer[pos]) {
 304   2                      case NOP:                       
 305   2                              lcd_print_string("NOP");
 306   2                              *cmdCond = NO_OP;
 307   2                              proto_send_done();
 308   2                              break;
 309   2                      case MOVE:
 310   2                              pos++;
 311   2                              speed = (char) (cmdBuffer[pos]);
 312   2                              pos++;
 313   2                              moveType = cmdBuffer[pos];
 314   2                              pos++;
 315   2                              switch(moveType) {
 316   3                                      case STRAIGHT:
 317   3                                              lcd_print_string("DRIVE_STRAIGHT");
 318   3                                              cmdCond = cmdBuffer + pos;                                      
 319   3                                              cmdCondPointer = cmdCond;
 320   3                                              if (proto_evaluate_cond(&cmdCondPointer)) {
 321   4                                                      driver_reset_pos();
 322   4                                                      driver_driveStraight(speed, TRIGGER_NONE, 0);
 323   4                                                      proto_wait_condition();
 324   4                                                      driver_stop();                                          
 325   4                                              }
 326   3                                              break;
 327   3                                      case TURN_LEFT:
 328   3                                      case TURN_RIGHT:
 329   3                                      {
 330   4                                              lcd_print_string("TURN_LEFT/RIGHT");
 331   4                                              cmdCond = cmdBuffer + (pos + 1);
 332   4                                              driver_reset_pos();
 333   4                                              driver_rotate(speed, ((moveType == TURN_LEFT) ? 1 : -1) * cmdBuffer[pos]);
 334   4                                              cmdCondPointer = cmdCond;
 335   4                                              while(proto_evaluate_cond(&cmdCondPointer)) {                                   
 336   5                                                      drvStatus = driver_status();                                            
 337   5                                                      if(drvStatus->mode == 3) {
 338   6                                                              break;
 339   6                                                      }                                                                                               
 340   5                                                      cmdCondPointer = cmdCond;
 341   5                                              }
 342   4                                              pos+=1;
 343   4                                              driver_stop();
 344   4                                      }
 345   3                                              break;
 346   3                              }
 347   2                              proto_send_done();
 348   2                              break;
 349   2                      case READ_VALUE:
 350   2                              lcd_print_string("READ_VALUE");
 351   2                              pos++;
 352   2                              cmdSendBuffer[0] = VALUE;
 353   2                              cmdSendBuffer[1] = cmdBuffer[pos];
 354   2                              {
 355   3                                      int val = proto_read_sensor(cmdBuffer[pos]);
 356   3                                      cmdSendBuffer[2] = (byte) (val >> 8);
 357   3                                      cmdSendBuffer[3] = (byte) (val & 0x00FF);
 358   3                              }
 359   2                              // proto_dump_message(cmdSendBuffer, 3);
 360   2                              proto_send(4);
 361   2                              break;
 362   2                      case NATIVE_CODE:
 363   2                              lcd_print_string("NATIVE_CODE");
C51 COMPILER V8.09   PROTOCOL_HANDLER                                                      06/18/2009 11:03:20 PAGE 7   

 364   2                              asm_call(cmdBuffer + 4);
 365   2                              proto_send_done();
 366   2                              break;
 367   2                      case GET_ENTRY_POINT:
 368   2                              lcd_print_string("GET_ENTRY_POINT");
 369   2                              cmdSendBuffer[0] = ENTRY_POINT;
 370   2                              cmdSendBuffer[1] = ((unsigned int) (cmdBuffer + 1)) >> 8;
 371   2                              cmdSendBuffer[2] = ((unsigned int) (cmdBuffer + 1)) & 0x00FF;
 372   2                              proto_send(3);
 373   2                              break;
 374   2                      case GET_FUNC_TABLE:
 375   2                              lcd_print_string("GET_FUNC_TABLE");
 376   2                              cmdSendBuffer[0] = FUNC_TABLE;
 377   2                              for (func = 0; func < FUNCTION_LAST; func++) {
 378   3                                      cmdSendBuffer[func * 2 + 1] = ((unsigned int) (asm_getFuncAddress(func))) >> 8;
 379   3                                      cmdSendBuffer[func * 2 + 2] = ((unsigned int) (asm_getFuncAddress(func))) & 0x00FF;
 380   3                              }
 381   2                              proto_send(FUNCTION_LAST * 2 + 1);
 382   2                              break;
 383   2              }
 384   1              cmdBufferPos = 0;
 385   1              cmdBuffer[cmdBufferPos] = '\0';
 386   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2591    ----
   CONSTANT SIZE    =    164    ----
   XDATA SIZE       =   2194      23
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
